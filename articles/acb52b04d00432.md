---
title: "「現場で役立つシステム設計原則」を読んだ"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["読書"]
published: false
---

## 小さくまとめる

- 短い名前とメソッド、小さなクラス
    - メソッド抽出してわかりやすく小さい処理にまとめる
- あいまいな基本データではなく、ドメインに沿った具体的な値オブジェクトを作成する
    - 不変にする
    - 入力制限やメソッドをデータに近いところに設けられる
    - わかりやすい名前がコードに表れ、取り違いも起きなくなる
- 配列という複雑性をコードに表出させないため、次のような処理をまとめた専用のコレクションオブジェクトを作成する
    - ループ処理のロジック
    - コレクション要素数、要素内容の変化
    - 0件の場合
    - 要素数の最小/最大制限

## 場合分けのロジックを整理する

- なるべくif文を使わない
    - 区分ごとに別のクラスに分けたりenumを使う方がわかりやすい
    - if文を使う場合、早期リターンやガード節でわかりやすく整理する

## 業務ロジックを整理する

- データとロジックのクラスを分けない
    - 汎用的な共通関数は理解していないメンバーは使えず自作関数がどんどん増えていく
    - クラスにデータとそのデータを使う判断/加工/計算のロジックを一緒に書く
    - データを使う側のクラスにロジックを書き始めたら設計を見直す
    - クラスが肥大化したら小さく分ける
- 三層 + ドメインモデルで整理する
    - プレゼンテーション層(Controller): UIなど外部との入出力を受け持つ
    - アプリケーション層(Service): 業務機能のマクロな手順の記述
    - データソース層(Repository): DBとの入出力を受け持つ
    - ドメインモデル: 業務データと関連する業務ロジックを表現したドメインオブジェクトの集合

## ドメインモデル

- ドメインモデルとなるものはERクラスと一致するわけではない（データではなく業務ロジックで整理する）
    - 重要な言葉とそうでない言葉を判断する
    - 言葉と言葉の関係性を見つける
- 業務の関心事はヒト/モノ/コトで整理する
    - ヒト: 業務活動の当事者。ドメインオブジェクトはヒトの意思/判断/行動についてのデータを持つ
    - モノ: ヒトが業務を遂行するときの関心の対象。数量/説明/状態/期間/位置などの属性を持つ
    - コト: 業務活動で起こる事象。ヒトの意思決定や行動の結果。対象/種別/時点の属性を持つ
- コトを整理の軸にする
    - コトはヒトとモノとの関係として出現する
    - コトは時間軸に沿って明確な前後関係を持つ
- 起きてよいこと/起きてはいけないことの判断と対応が業務ルール
    - コトが起きてよいかの妥当性の確認
    - 妥当であった/妥当でなかった場合の次のアクション
    - コトの予定と実績から差異を検知/判定する
    - 想定外のコトが起きたときの対応
- ドメインオブジェクトの設計パターン
    - 値オブジェクト: 数値、日付、文字列をラッピングしてロジックを整理する
    - コレクションオブジェクト: 配列やコレクションをラッピングしてロジックを整理する
    - 区分オブジェクト: 区分の定義と区分ごとのロジックを整理する
    - 列挙型の集合操作: 状態遷移ルールなどを列挙型の集合として整理する
    - これらの小さな独立性の高いドメインオブジェクトを組み合わせて業務の主たる関心となるドメインオブジェクトを作る
- 業務の関心事のパターン（これらに上の設計パターンを当てはめていく）
    - 口座パターン: 現在の値を表現し、妥当性を管理する
    - 期日パターン: 約束の期日と判断を表現する
    - 方針パターン: さまざまなルールが複合する、複雑な業務ロジックを表現する
    - 状態パターン: 状態と状態遷移のできる/できないを表現する

## アプリケーション層(Service)

- 業務ロジックはサービスクラスには書かずシンプルに保つ
- ひとつのサービスクラスの中で参照/更新を同時に行わず、サービスクラスを参照/更新系に分けるとシンプルに保ちやすい
- 更新系のサービスクラスは何も情報を返さない
- 参照/更新系サービスクラスを組み立てるシナリオクラスを作りプレゼンテーション層から呼ぶ
- サービスを提供する側がなにが入ってくるかを検査するのではなく、サービスを利用する側がサービスを使う前の約束を決める
    - nullを渡さない/nullを返さない
    - 状態に依存する場合、使う側が事前に確認する
    - 異常が起きた場合、サービスを使う側が例外を通知する
- DB操作の都合はサービスクラスには表出させずデータソース層に任せる

### 参照系と更新系にサービスを分け、シナリオサービスでそれらを組み立てる

```java
// 参照系サービス
@Service
class BankAccountService {
    @Autowired
    BankAccountRepository repository;

    Amount balance() {
        return repository.balance();
    }

    boolean canWithdraw(Amount amount) {
        Amount balance = balance();
        return balance.has(amount);
    }
}

// 更新系サービス
@Service
class BankAccountUpdateService {
    @Autowired
    BankAccountRepository repository;

    void withdraw(Amount amount) {
        repository.withdraw(amount);
    }
}

// 組み立てサービス
@Service
class BankAccountSenario {
    @Autowired
    BankAccountService queryService;
    @Autowired
    BankAccountUpdateService updateService;

    Amount withdraw(Amount amount) {
        if (! queryService.canWithdraw(amount)) throw new IllegalStateException("残高不足");

        updateService.withdraw(amount);
        return queryService.balance();
    }
}
```

## 感想

- システム設計というかほぼDDD本だった
    - DDDこそ破綻しない唯一のシステム設計みたいなことかもしれない
    - タイトルにはDDDの文字は一切ないけど入れといた方がわかりやすいのでは
- 前に読んだDDD本よりわかりやすかった
